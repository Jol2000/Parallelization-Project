# Parallelization-Project
## **Introduction** 

The software application I’ve chosen to parallelise is bioinformatics, k-mer signatures, associated with computational genomics and sequence analysis, this application is written in C++, and operates by reading a .fasta file (binary format) containing sequences, then computing a k-mer signature for each sequence, and saving these signatures into a binary file format. In bioinformatics, k-mers are substrings of length k contained within a genomic sequence, which represents certain signatures to describe different genomes or regions in a sequence. Moreover, the frequency set of k-mers in a class of genomic sequences can be classified as a “signature” of the underlying sequence, and when comparing frequencies, it’s computationally easier than sequence alignment, which's defined as a way of arranging genomic sequences to identify similarities between sequences. Furthermore, it’s also an important method in alignment-free sequence analysis which approaches molecular sequence, and structure data providing an alternative over alignment-based approaches.

Moving on, I’ve constructed a class diagram shown below in figure 1.1 to provide a visual representation of the original sequential applications’ structure, and the functions shown in the diagram can be found within the signature.cpp file as it’s the main program. The application begins at the main function where it loads a .fasta file, then writes signatures into an output file created by the function, and from figure 1.2, we can see that the while loop reads lines from the .fasta file to compute and write signatures for each sequence. Moreover, the partition function (fig 2.1) utilises compute_signature in computing signatures for each partition of a sequence, and compute_signature (fig 2.3) uses an array called doc_sig to store signatures for a specific partition. Additionally, signatures are stored within the doc_sig array by using signature_add, where signature_add uses a function called, find_sig to retrieve signatures, and iterates over each signature in order to be added to doc_sig. Furthermore, find_sig utilises another function called compute_new_term_sig to create new signatures, and the computed signatures from this function are then added to a hashmap, this hashmap is a critical component for the program as it ensures that if similar names or values were to appear, signatures wouldn’t need to be recomputed, but can instead be retrieved from this hashmap.
